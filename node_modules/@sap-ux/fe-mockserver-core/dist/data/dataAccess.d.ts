import type { EntitySet, EntityType, NavigationProperty, Singleton } from '@sap-ux/vocabularies-types';
import type { ILogger } from '@ui5/logger';
import type { ServiceConfig } from '../api';
import type { IFileLoader } from '../index';
import type { ExpandDefinition, KeyDefinitions } from '../request/odataRequest';
import ODataRequest from '../request/odataRequest';
import type { IncomingMessageWithTenant } from '../router/serviceRouter';
import type { DataAccessInterface, EntitySetInterface } from './common';
import { MockDataEntitySet } from './entitySets/entitySet';
import { StickyMockEntitySet } from './entitySets/stickyEntitySet';
import type { ODataMetadata } from './metadata';
type ApplyToExpandTreeFunction = (this: DataAccess, data: Record<string, any>, entityType: EntityType, navigationProperty: NavigationProperty, targetEntitySet: EntitySet | Singleton | undefined, expandDefinition: ExpandDefinition, odataRequest: ODataRequest) => Promise<void>;
type Data = Record<string, any> | undefined | null;
/**
 *
 */
export declare class DataAccess implements DataAccessInterface {
    private service;
    private metadata;
    fileLoader: IFileLoader;
    protected readonly mockDataRootFolder: string;
    debug: boolean;
    log: ILogger;
    protected readonly strictKeyMode: boolean;
    protected readonly contextBasedIsolation: boolean;
    protected entitySets: Record<string, MockDataEntitySet>;
    protected stickyEntitySets: StickyMockEntitySet[];
    protected generateMockData: boolean;
    protected forceNullableValuesToNull: boolean;
    constructor(service: ServiceConfig, metadata: ODataMetadata, fileLoader: IFileLoader);
    isV4(): boolean;
    private initializeMockData;
    reloadData(newMetadata?: ODataMetadata): void;
    getMockEntitySet(entityTypeName?: string, generateMockData?: boolean, forceNullableValuesToNull?: boolean, containedEntityType?: EntityType, containedData?: any): Promise<EntitySetInterface>;
    performAction(odataRequest: ODataRequest, bodyActionData?: object): Promise<any>;
    getNavigationPropertyKeys(data: any, navPropDetail: NavigationProperty, currentEntityType: EntityType, currentEntitySet: EntitySet | Singleton | undefined, currentKeys: KeyDefinitions, tenantId: string, forCreate?: boolean): Promise<KeyDefinitions>;
    applyToExpandTree(currentEntitySet: EntitySet | Singleton | undefined, entityType: EntityType, expandNavProp: string, data: Data | Data[], requestExpandObject: Record<string, ExpandDefinition>, previousEntitySet: EntitySet | Singleton | undefined, visitedPaths: string[], odataRequest: ODataRequest, functionToApply: ApplyToExpandTreeFunction): Promise<Data>;
    /**
     * Applies $expand.
     *
     * @param data               The data to expand
     * @param entityType         Entity type of the data
     * @param navigationProperty The navigation property to expand
     * @param targetEntitySet    The expanded entity set
     * @param _expandDefinition
     * @param odataRequest
     */
    private applyExpand;
    /**
     * Applies $select.
     *
     * @param data              Data to process
     * @param selectDefinition  Selected properties
     * @param expandDefinitions Expanded properties
     * @param entityType        Entity type of the data
     */
    private applySelect;
    /**
     * Applies post-processing of expand options, such as removing properties that were not selected.
     *
     * @param data  The data to process
     * @param _entityType  Entity type of the data
     * @param navigationProperty  The expanded navigation property to process
     * @param targetEntitySet   The target entity set of the expanded navigation property
     * @param expandDefinition  The expand definition with all parameters
     * @param odataRequest
     */
    private applyExpandOptions;
    getMetadata(): ODataMetadata;
    getData(odataRequest: ODataRequest, dontClone?: boolean): Promise<any>;
    updateData(odataRequest: ODataRequest, patchData: any): Promise<any>;
    createData(odataRequest: ODataRequest, postData: any): Promise<any>;
    private addV2Metadata;
    private getV2KeyString;
    deleteData(odataRequest: ODataRequest): Promise<void>;
    getDraftRoot(keyValues: KeyDefinitions, _tenantId: string, entitySetDefinition: EntitySet): Promise<{}>;
    /**
     * Check whether there is a valid session with the given context ID.
     *
     * @param request The incoming request
     * @throws ExecutionError if there is a context ID, but there is no corresponding session
     */
    checkSession(request: ODataRequest | IncomingMessageWithTenant): void;
    resetStickySessionTimeout(odataRequest: ODataRequest): void;
    private _applyOrderBy;
    private _applyGroupBy;
    private _applyFilter;
    private lastFilterTransformationResult;
    private applyTransformation;
}
export {};
//# sourceMappingURL=dataAccess.d.ts.map